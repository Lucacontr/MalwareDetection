import time
import pandas as pd
from sklearn.model_selection import train_test_split, KFold
from imblearn.over_sampling import SMOTE
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
from qiskit import Aer
from qiskit.utils import QuantumInstance, algorithm_globals
from qiskit.algorithms.optimizers import COBYLA
from qiskit_machine_learning.neural_networks import TwoLayerQNN
from qiskit_machine_learning.algorithms.classifiers import NeuralNetworkClassifier
from IPython.display import clear_output
from sklearn.svm import SVC


def callback_graph(weights, obj_func_eval, objective_func_vals=[]):
    clear_output(wait=True)
    objective_func_vals.append(obj_func_eval)
    plt.title("Objective function value against iteration")
    plt.xlabel("Iteration")
    plt.ylabel("Objective function value")
    plt.plot(range(len(objective_func_vals)), objective_func_vals)
    plt.show()

data = pd.read_csv("dataset/dataset.csv")
data = data.drop(columns='appeared')
data = data.drop('sha256', axis=1)
features = data.drop(columns='label').values
labels = data['label'].values

kf = KFold(n_splits=10, shuffle=False)
max = 0
train_features, train_labels, test_features, test_labels = [], [], [], []
for training_index, testing_index in kf.split(features):
    x_train, x_test = features[training_index], features[testing_index]
    y_train, y_test = labels[training_index], labels[testing_index]
    model = SVC(kernel="linear")
    model.fit(x_train, y_train)
    score = model.score(x_test, y_test)
    if score > max:
        max = score
        train_features = x_train
        train_labels = y_train
        test_features = x_test
        test_labels = y_test

# Feature Extraction
pca = PCA(2)
pca.fit(train_features)
train_features_pca = pca.transform(train_features)
test_features_pca = pca.transform(test_features)

# Data Balancing
sm = SMOTE()
train_features_bal, train_labels_bal = sm.fit_resample(train_features_pca, train_labels)

num_qubits = 2
quantum_instance = QuantumInstance(Aer.get_backend("aer_simulator"), shots=1024)

# construct QNN
opflow_qnn = TwoLayerQNN(num_qubits, quantum_instance=quantum_instance)
# QNN maps inputs to [-1, +1]
opflow_qnn.forward(train_features_bal[0, :], algorithm_globals.random.random(opflow_qnn.num_weights))

# construct neural network classifier
opflow_classifier = NeuralNetworkClassifier(opflow_qnn, optimizer=COBYLA(maxiter=50), callback=callback_graph)
# create empty array for callback to store evaluations of the objective function
objective_func_vals = []
plt.rcParams["figure.figsize"] = (12, 6)

start_time = time.time()
# fit classifier to data
opflow_classifier.fit(train_features_bal, train_labels_bal)

# return to default figsize
plt.rcParams["figure.figsize"] = (6, 4)

# score classifier
score = (opflow_classifier.score(test_features_pca, test_labels))*100
print("TwoLayerQNN accuracy: " + score.__str__())
total_time = time.time() - start_time
print("Train effettuato in " + str(total_time))

# evaluate data points
y_predict = opflow_classifier.predict(test_features_pca)

# plot results
# red == wrongly classified
for x, y_target, y_p in zip(train_features_bal, train_labels_bal, y_predict):
    if y_target == 1:
        plt.plot(x[0], x[1], "bo")
    else:
        plt.plot(x[0], x[1], "go")
    if y_target != y_p:
        plt.scatter(x[0], x[1], s=200, facecolors="none", edgecolors="r", linewidths=2)
plt.plot([-1, 1], [1, -1], "--", color="black")
plt.show()




